# 介面與 Mock 測試 - 完整學習筆記

## 📌 核心問題：為什麼要用介面？

簡單說：**用介面能讓測試變簡單、快速、穩定**

---

## 1️⃣ 基礎概念

### 什麼是介面？
- 介面是一份**契約**（合約）
- 規定實現它的類別**必須有哪些方法**
- 但**不包含方法的具體實現**

### 什麼是依賴注入？
- 不在類別內部創建依賴
- 改成透過**建構函式傳入**
- 這樣可以靈活替換依賴

### 什麼是 Mock？
- Mock 是**假的物件**
- 專門用來**模擬真實物件的行為**
- 用在測試中隔離程式碼

---

## 2️⃣ 沒有介面 vs 有介面

### ❌ 沒有介面的寫法

```csharp
public class BadApplication
{
    private Installer _installer;

    public BadApplication()
    {
        // ❌ 在建構函式中直接建立
        _installer = new Installer();
    }

    public bool InstallApplication(string url)
    {
        if (!_installer.ValidateUrl(url)) return false;
        return _installer.Install(url);
    }
}
```

**測試時的問題：**
```csharp
var app = new BadApplication();
// ❌ 無法控制 Installer 的行為
// ❌ 會真的執行 URL 驗證（很慢）
// ❌ 會真的執行安裝邏輯
// ❌ 測試依賴外部環境（數據庫、網路等）
// ❌ 無法測試異常情況
```

---

### ✅ 有介面的寫法

```csharp
// 第一步：定義介面
public interface IInstaller
{
    bool Install(string url);
    bool ValidateUrl(string url);
}

// 第二步：實現介面
public class Installer : IInstaller
{
    public bool Install(string url)
    {
        return true;
    }

    public bool ValidateUrl(string url)
    {
        var regex = new Regex(@"^https?://...");
        return regex.IsMatch(url);
    }
}

// 第三步：依賴介面，不是具體類別
public class GoodApplication
{
    private readonly IInstaller _installer;

    // 透過建構函式注入（傳入介面）
    public GoodApplication(IInstaller installer)
    {
        _installer = installer;
    }

    public bool InstallApplication(string url)
    {
        if (!_installer.ValidateUrl(url)) return false;
        return _installer.Install(url);
    }
}
```

---

## 3️⃣ 測試時的差異

### 測試沒有介面的類別

```csharp
// 無法寫成這樣：
var app = new BadApplication(mockInstaller);  // ❌ 不支持

// 只能這樣：
var app = new BadApplication();  // 必須用真實的 Installer
```

### 測試有介面的類別

```csharp
// 第一步：建立 Mock 物件
var mockInstaller = Substitute.For<IInstaller>();

// 第二步：配置 Mock 的行為
mockInstaller.ValidateUrl("test").Returns(false);
mockInstaller.ValidateUrl("https://www.google.com").Returns(true);
mockInstaller.Install(Arg.Any<string>()).Returns(true);

// 第三步：傳入 Mock
var app = new GoodApplication(mockInstaller);

// 第四步：測試
var result = app.InstallApplication("test");
Assert.That(result, Is.EqualTo(false));
```

---

## 4️⃣ 實際測試代碼示例

### 測試正常流程

```csharp
[TestCase("test", false)]  // 無效 URL → 返回 False
[TestCase("https://www.google.com", true)]  // 有效 URL → 返回 True
public void InstallApplication_WithUrlValidation_ReturnsCorrectResult(
    string url, 
    bool expected)
{
    // Arrange（準備）
    var installer = Substitute.For<IInstaller>();
    
    // 配置 Mock：根據 URL 返回不同結果
    installer.ValidateUrl(url).Returns(url == "https://www.google.com");
    installer.Install(url).Returns(true);
    
    var app = new GoodApplication(installer);

    // Act（執行）
    var result = app.InstallApplication(url);

    // Assert（驗證）
    Assert.That(result, Is.EqualTo(expected));
}
```

### 測試異常情況

```csharp
[Test]
public void InstallApplication_WhenInstallException_ThrowsException()
{
    // Arrange
    var installer = Substitute.For<IInstaller>();
    
    installer.ValidateUrl("test").Returns(true);
    
    // 模擬異常：當呼叫 Install 時拋出異常
    installer
        .When(x => x.Install("test"))
        .Do(x => { throw new Exception("安裝失敗"); });
    
    var app = new GoodApplication(installer);

    // Assert：驗證異常被正確拋出
    Assert.That(
        () => app.InstallApplication("test"), 
        Throws.Exception
    );
}
```

---

## 5️⃣ 優缺點對比表

| 特性 | 沒介面 ❌ | 有介面 ✅ |
|------|---------|---------|
| 可以用 Mock | 不行 | 可以 |
| 測試速度 | 🐢 慢（可能幾秒）| 🚀 快（毫秒）|
| 測試穩定性 | ❌ 依賴外部 | ✅ 完全隔離 |
| 異常測試 | ❌ 困難 | ✅ 容易 |
| 代碼耦合度 | 🔴 高 | 🟢 低 |
| 易於修改 | ❌ 困難 | ✅ 容易 |
| 易於擴展 | ❌ 困難 | ✅ 容易 |

---

## 6️⃣ 真實世界例子：餐廳訂單系統

想像你要測試一個**下單系統**，需要：
1. 向銀行扣款
2. 安排物流配送

### ❌ 沒有介面的寫法

```csharp
public class OrderService
{
    private PaymentProcessor paymentProcessor;
    private ShippingService shippingService;

    public OrderService()
    {
        // ❌ 硬編碼依賴
        paymentProcessor = new PaymentProcessor();
        shippingService = new ShippingService();
    }

    public bool PlaceOrder(string orderId, decimal amount)
    {
        // 會真的扣款！
        if (!paymentProcessor.Charge(orderId, amount))
            return false;

        // 會真的寄貨！
        return shippingService.Schedule(orderId);
    }
}
```

**問題：**
- ❌ 每次測試都會**真的扣款**
- ❌ 每次測試都會**真的寄貨**
- ❌ 測試需要 **8 秒**（5秒扣款 + 3秒寄貨）
- ❌ 銀行系統掛掉，測試就失敗

### ✅ 使用介面的寫法

```csharp
public interface IPaymentProcessor
{
    bool Charge(string orderId, decimal amount);
}

public interface IShippingService
{
    bool Schedule(string orderId);
}

public class GoodOrderService
{
    private readonly IPaymentProcessor _paymentProcessor;
    private readonly IShippingService _shippingService;

    public GoodOrderService(
        IPaymentProcessor paymentProcessor,
        IShippingService shippingService)
    {
        _paymentProcessor = paymentProcessor;
        _shippingService = shippingService;
    }

    public bool PlaceOrder(string orderId, decimal amount)
    {
        if (!_paymentProcessor.Charge(orderId, amount))
            return false;
        return _shippingService.Schedule(orderId);
    }
}
```

**測試：**

```csharp
[Test]
public void PlaceOrder_PaymentFails_ReturnsFalse()
{
    // Arrange：建立 Mock
    var paymentMock = Substitute.For<IPaymentProcessor>();
    var shippingMock = Substitute.For<IShippingService>();

    // 模擬支付失敗
    paymentMock.Charge(Arg.Any<string>(), Arg.Any<decimal>()).Returns(false);

    var service = new GoodOrderService(paymentMock, shippingMock);

    // Act
    var result = service.PlaceOrder("ORDER001", 100m);

    // Assert
    Assert.IsFalse(result);
    
    // ✅ 沒有真的扣款
    // ✅ 沒有真的寄貨
    // ✅ 測試在毫秒內完成
}
```

**優點：**
- ✅ 不會真的扣款
- ✅ 不會真的寄貨
- ✅ 測試在毫秒內完成
- ✅ 每次結果相同，穩定可靠

---

## 7️⃣ 核心概念總結

### 三大支柱

| 概念 | 作用 | 例子 |
|------|------|------|
| **介面** | 定義契約，不實現邏輯 | `IInstaller`, `IPaymentProcessor` |
| **依賴注入** | 透過參數傳入依賴，而不是硬編碼 | `public MyClass(IMyDependency dep)` |
| **Mock** | 模擬物件，用於測試 | `Substitute.For<IInstaller>()` |

### 執行流程示意圖

```
測試時發生什麼
══════════════════════════════════════════

1. var mockInstaller = Substitute.For<IInstaller>();
   → 建立一個假的 IInstaller

2. mockInstaller.ValidateUrl("test").Returns(false);
   → 設定：當呼叫 ValidateUrl("test") 時，返回 false

3. var app = new GoodApplication(mockInstaller);
   → 把假的傳給 GoodApplication

4. app.InstallApplication("test")
   → GoodApplication 呼叫 mockInstaller.ValidateUrl("test")
   → Mock 返回 false（因為我們設定過）
   → GoodApplication 直接返回 false

5. Assert.That(result, Is.EqualTo(false));
   → 驗證結果符合預期 ✅
```

---

## 8️⃣ 為什麼介面讓測試更好？

### 1️⃣ 隔離 (Isolation)
- 只測試你想測的類別
- 不受依賴的影響
- 一個測試失敗不會影響其他測試

### 2️⃣ 速度 (Speed)
- Mock 不執行真實邏輯
- 毫秒級完成
- 1000 倍快於真實依賴

### 3️⃣ 穩定性 (Stability)
- 完全控制行為
- 不依賴外部環境
- 每次結果相同

### 4️⃣ 靈活性 (Flexibility)
- 容易模擬異常
- 容易測試邊界情況
- 容易測試各種組合

### 5️⃣ 代碼品質 (Quality)
- 寬鬆耦合
- 易於修改
- 易於擴展

---

## 9️⃣ 什麼時候應該使用介面？

### ✅ 一定要用介面

1. **外部服務**：數據庫、API、檔案系統
2. **耗時操作**：網路請求、IO 操作、複雜計算
3. **難以控制的資源**：時間、隨機數、密鑰
4. **有副作用的操作**：發送郵件、下單、付款
5. **需要測試異常的地方**：失敗、超時、崩潰

### ⚠️ 可以不用介面

1. **純計算**：Math.Sqrt、複利計算
2. **簡單轉換**：格式化、驗證
3. **標準庫**：List、Dictionary

但即使這些情況，用介面也不會有害！

---

## 🔟 實踐步驟

### 第一步：識別依賴

```csharp
public class MyService
{
    private Logger logger;        // ← 依賴 1
    private Database db;          // ← 依賴 2
    private EmailSender email;    // ← 依賴 3
}
```

### 第二步：建立介面

```csharp
public interface ILogger { void Log(string msg); }
public interface IDatabase { User GetUser(int id); }
public interface IEmailSender { void Send(string to, string body); }
```

### 第三步：透過建構函式注入

```csharp
public class MyService
{
    private readonly ILogger _logger;
    private readonly IDatabase _db;
    private readonly IEmailSender _email;

    public MyService(
        ILogger logger,
        IDatabase db,
        IEmailSender email)
    {
        _logger = logger;
        _db = db;
        _email = email;
    }
}
```

### 第四步：測試時使用 Mock

```csharp
[Test]
public void MyTest()
{
    var loggerMock = Substitute.For<ILogger>();
    var dbMock = Substitute.For<IDatabase>();
    var emailMock = Substitute.For<IEmailSender>();

    var service = new MyService(loggerMock, dbMock, emailMock);
    
    // 配置 Mock 行為
    dbMock.GetUser(1).Returns(new User { Id = 1, Name = "Alice" });
    
    // 測試...
}
```

---

## 1️⃣1️⃣ 常見 NSubstitute 用法

### 基本設定

```csharp
// 建立 Mock
var mock = Substitute.For<IMyInterface>();

// 設定返回值
mock.MyMethod("param").Returns("result");

// 設定返回值（使用 Arg.Any）
mock.MyMethod(Arg.Any<string>()).Returns("result");

// 設定多個返回值
mock.MyMethod("test1").Returns("result1");
mock.MyMethod("test2").Returns("result2");
```

### 模擬異常

```csharp
// 拋出異常
mock.MyMethod(Arg.Any<string>())
    .Do(x => { throw new Exception("出錯了"); });

// 或使用 When
mock.When(x => x.MyMethod("test"))
    .Do(x => { throw new Exception(); });
```

### 驗證呼叫

```csharp
// 驗證被呼叫過
mock.Received(1).MyMethod("test");

// 驗證沒有被呼叫
mock.DidNotReceive().MyMethod("test");

// 驗證被呼叫任意次
mock.Received().MyMethod(Arg.Any<string>());
```

---

## 1️⃣2️⃣ 總結：你已經在做最佳實踐！

你的代碼已經正確地使用了：

✅ **介面** - `IInstaller`  
✅ **依賴注入** - `public NewApplication(IInstaller installer)`  
✅ **Mock 測試** - `Substitute.For<IInstaller>()`  

這就是專業的單元測試寫法！

---

## 📚 進階主題

### SOLID 原則

你使用的設計符合 SOLID 原則：

- **S** (Single Responsibility)：每個類別只負責一件事
- **O** (Open/Closed)：開放擴展，關閉修改
- **L** (Liskov Substitution)：子類別可替換父類別 ← **介面就是這個**
- **I** (Interface Segregation)：用介面定義契約
- **D** (Dependency Inversion)：依賴抽象，不依賴具體

### 進一步學習

1. **Dependency Injection 容器**：自動注入依賴
2. **測試驅動開發 (TDD)**：先寫測試，再寫程式
3. **集成測試**：測試多個組件的協作

---

## 🎯 最後的話

**為什麼介面讓測試變得更好？**

簡單說：
> 介面讓你**用假的替代真的**  
> 假的快、穩定、可控  
> 所以測試也快、穩定、可控

就這麼簡單！🚀

---

## 📎 附錄：常見問題

### Q1: 不用介面會怎樣？
A: 測試時無法用 Mock，會執行真實邏輯，測試變慢、不穩定。

### Q2: 每個依賴都要介面嗎？
A: 原則上是，但標準庫（List、Dictionary）除外。

### Q3: 介面會讓代碼變複雜嗎？
A: 初期會多一些代碼，但長期來看代碼更好維護。

### Q4: Mock 真的有必要嗎？
A: 是的，特別是依賴外部服務、耗時操作的時候。

### Q5: 其他 Mock 庫有哪些？
A: Moq、Rhino Mocks、FakeItEasy 等，但 NSubstitute 是最易用的。

