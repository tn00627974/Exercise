# 一張圖勝千言 - Arg.Any vs 具體物件

## 最簡單的對比圖

```
┌─────────────────────────────────────────────────────┐
│           Arg.Any<Order>()                          │
│        （99% 的測試都用這個）                       │
├─────────────────────────────────────────────────────┤
│                                                      │
│  設定：任何 Order 都返回 success                    │
│                                                      │
│  ? Order ORD001 → success                          │
│  ? Order ORD002 → success                          │
│  ? Order ORD003 → success                          │
│  ? Order 隨便什麼 → success                        │
│                                                      │
│  Mock 的心態：「我不挑，來什麼都行」                │
│                                                      │
└─────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────┐
│           order 具體物件                            │
│         （很少用，容易出錯）                        │
├─────────────────────────────────────────────────────┤
│                                                      │
│  var order = new Order { OrderNo = "ORD001" }      │
│  設定：只有這個特定的 order 返回 success           │
│                                                      │
│  ? 傳入同一個 order → success                      │
│  ? 傳入新的 Order ORD001 → NOT_SET                │
│  ? 傳入新的 Order ORD002 → NOT_SET                │
│  ? 傳入隨便什麼 → NOT_SET                          │
│                                                      │
│  Mock 的心態：「我只認這一個，其他都拒絕」         │
│                                                      │
└─────────────────────────────────────────────────────┘
```

---

## 你的代碼到底發生了什麼？

```
原始代碼：
??????????????????????????????????????????????????

_mockSender.Send(Arg.Any<Order>()).Returns(expectedResult);  ← 設定 1
_mockSender.Send(order).Returns(expectedResult);              ← 設定 2


時間線：
??????????????????????????????????????????????????

T1（執行第一行）
┌────────────────────────────┐
│ Mock 的設定：               │
│ ? 任何 Order 都返回 result │
└────────────────────────────┘

        ↓↓↓ 執行第二行 ↓↓↓

T2（執行第二行）
┌────────────────────────────┐
│ 新設定來了，覆蓋舊設定      │
│ ? 只有這個 order 返回      │
│   result（其他都不理）      │
└────────────────────────────┘
   ↑ 第一行的設定被刪除了！

        ↓↓↓ 執行測試 ↓↓↓

T3（測試執行 send(order)）
┌────────────────────────────┐
│ Mock 查詢當前設定：          │
│ 「是那個特定的 order？」     │
│ 是！→ 返回 result ?         │
└────────────────────────────┘

結論：測試通過，但是因為設定 2，不是設定 1！


修正代碼：
??????????????????????????????????????????????????

_mockSender.Send(Arg.Any<Order>()).Returns(expectedResult);

        ↓↓↓ 執行測試 ↓↓↓

Mock 查詢當前設定：
「是 Order 型別？」
是！→ 返回 result ?

結論：測試通過，設定清晰單一！
```

---

## 內存中的差異

```
情況 1：Arg.Any<Order>()


Mock 內部：
┌─────────────────────────────┐
│ 規則：接受任何 Order        │
│                             │
│ 類型檢查：Order? ?        │
│ 內容檢查：不看              │
│ 位址檢查：不看              │
└─────────────────────────────┘

執行流程：
send(new Order{})  →  類型是 Order? ?  →  返回 result
send(new Order{})  →  類型是 Order? ?  →  返回 result
send(new Order{})  →  類型是 Order? ?  →  返回 result


情況 2：order 具體物件


var order = new Order();  // 位址：0xABCD

Mock 內部：
┌─────────────────────────────┐
│ 規則：位址必須是 0xABCD    │
│                             │
│ 類型檢查：Order? ?        │
│ 內容檢查：不看              │
│ 位址檢查：== 0xABCD? 必須   │
└─────────────────────────────┘

執行流程：
send(order)          →  位址 0xABCD? ?  →  返回 result
send(new Order{})    →  位址 0x1234? ?  →  不返回
send(new Order{})    →  位址 0x5678? ?  →  不返回
                         (即使內容相同也不行)
```

---

## 決策樹

```
                    我需要 Mock 一個方法的參數
                           |
                           V
                    ┌───────────────┐
                    │ 參數很重要嗎？ │
                    └───────────────┘
                      /           \
                    是             否
                    /               \
                   V                 V
            ┌──────────────┐    ┌──────────────┐
            │ 需要檢查     │    │ 不檢查內容   │
            │ 參數的內容？ │    │ 任何都可以   │
            └──────────────┘    └──────────────┘
              /         \              |
            是           否            |
            /             \           |
           V               V          V
      ┌─────────┐    ┌──────────┐  ┌──────────┐
      │ Arg.Is  │    │ Arg.Any  │  │ Arg.Any  │
      │ < >     │    │ < >      │  │ < >      │
      └─────────┘    └──────────┘  └──────────┘
         進階           99%情況        99%情況
```

---

## 記住這一個就夠了！

```
歈
                                                      
         99% 的情況，就用：Arg.Any<Order>()          
                                                      
              _mockSender.Send(                       
                  Arg.Any<Order>()                    
              ).Returns(expectedResult);              
                                                      
         別想太多，就是這一句！                      
                                                      
裺
```

---

## 檢查清單

- [ ] 我理解了 `Arg.Any<T>()` 是什麼
- [ ] 我理解了具體物件 `order` 是什麼
- [ ] 我知道為什麼不要同時寫兩行
- [ ] 我知道 99% 的時候用 `Arg.Any<T>()`
- [ ] 我已經修改我的測試代碼
- [ ] 我可以解釋給朋友聽為什麼有差別

---

**現在你完全理解了！** ??

你現在知道的比 90% 的開發者都多！
