# ?? 第 6 關快速參考卡

## 5 分鐘快速理解

### 問題
你有一個 `EmailNotificationSender`，想添加「日誌、重試、超時」功能。

```csharp
// ? 方法 1：修改 EmailNotificationSender
// 問題：代碼膨脹，職責混亂
public class EmailNotificationSender : INotificationSender
{
    public NotificationResult Send(Order order)
    {
        // 原有邏輯 (50 行)
        // + 日誌邏輯 (40 行)
        // + 重試邏輯 (60 行)
        // + 超時邏輯 (50 行)
        // = 總共 200 行，難以維護！
    }
}
```

### 解決方案：裝飾器模式
```csharp
// ? 方法 2：用裝飾器組合
var sender = new EmailNotificationSender();
var withLog = new LoggingNotificationSenderDecorator(sender);
var withRetry = new RetryNotificationSenderDecorator(withLog);
var withTimeout = new TimeoutNotificationSenderDecorator(withRetry);

// 每個類只做一件事，可以任意組合
```

---

## 核心代碼樣版

### 裝飾器模式的三要素

```csharp
public class MyNotificationSenderDecorator : INotificationSender
{
    // 1?? 持有被裝飾的對象
    private readonly INotificationSender _innerSender;

    // 2?? 通過構造子注入
    public MyNotificationSenderDecorator(INotificationSender innerSender)
    {
        _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
    }

    // 3?? 實現同樣的接口，添加額外功能
    public NotificationResult Send(Order order)
    {
        // 前置邏輯（例如：記錄開始）
        Console.WriteLine($"[LOG] 開始發送...");

        // 呼叫被裝飾的對象
        var result = _innerSender.Send(order);

        // 後置邏輯（例如：記錄結果）
        Console.WriteLine($"[LOG] 發送完成：{result.Message}");

        return result;
    }
}
```

---

## 第 6 關的 3 個裝飾器

### 1?? LoggingNotificationSenderDecorator
**目的**：記錄發送過程  
**職責**：Console.WriteLine()  
**測試**：驗證輸出訊息正確傳遞

### 2?? RetryNotificationSenderDecorator
**目的**：失敗自動重試  
**職責**：重試邏輯，延遲  
**測試**：驗證 Received() 呼叫次數正確

### 3?? TimeoutNotificationSenderDecorator
**目的**：避免卡死  
**職責**：超時控制  
**測試**：驗證超時後返回失敗

---

## 測試樣版

### 測試 Mock 返回多個結果

```csharp
[Test]
public void Send_FailsThenSucceeds_RetryUntilSuccess()
{
    // Arrange
    var mockSender = Substitute.For<INotificationSender>();
    var failResult = new NotificationResult { Success = false };
    var successResult = new NotificationResult { Success = true };

    // ?? 關鍵：第一次返回 failResult，第二次返回 successResult
    mockSender.Send(Arg.Any<Order>())
        .Returns(failResult)      // 第 1 次
        .AndThen(successResult);  // 第 2 次

    var decorator = new RetryNotificationSenderDecorator(mockSender);

    // Act
    var result = decorator.Send(new Order { OrderNo = "ORD001", Amount = 100 });

    // Assert
    Assert.That(result.Success, Is.True);
    mockSender.Received(2).Send(Arg.Any<Order>());  // 驗證呼叫 2 次
}
```

---

## 組合順序很重要！

```csharp
// ? 順序 A：超時控制最外層，日誌最內層
var sender = new LoggingDecorator(
    new RetryDecorator(
        new TimeoutDecorator(
            new EmailNotificationSender()
        )
    )
);
// 執行順序：LOG → RETRY → TIMEOUT → EMAIL
// 問題：超時發生在日誌和重試之後才生效

// ? 順序 B：超時控制最外層（第一個保護所有後續操作）
var sender = new TimeoutDecorator(
    new RetryDecorator(
        new LoggingDecorator(
            new EmailNotificationSender()
        )
    )
);
// 執行順序：TIMEOUT → RETRY → LOG → EMAIL
// ? 如果超時，整個重試都會被中斷
```

---

## 檔案建立清單

```
? OrderNotificationSystem/Decorators/
   ├─ LoggingNotificationSenderDecorator.cs      (110 行)
   ├─ RetryNotificationSenderDecorator.cs        (90 行)
   └─ TimeoutNotificationSenderDecorator.cs      (70 行)

? OrderNotificationSystemTests/Unit/Decorators/
   ├─ LoggingDecoratorTests.cs                   (3 個測試)
   ├─ RetryDecoratorTests.cs                     (4 個測試)
   └─ TimeoutDecoratorTests.cs                   (3 個測試)

總共：6 個新檔案，10 個新測試
```

---

## 執行順序

```bash
# 1. 建立資料夾
mkdir OrderNotificationSystem\Decorators
mkdir OrderNotificationSystemTests\Unit\Decorators

# 2. 複製檔案（從 MD 檔案）
# ...複製 6 個檔案...

# 3. 執行測試
dotnet test

# 4. 預期結果
# ========== Test Execution Summary ==========
# Total: 10
# Passed: 10 ?
# Failed: 0
# =======================================
```

---

## Mock 的兩種返回方式

### 方式 1：Single Return（簡單情況）
```csharp
mockSender.Send(Arg.Any<Order>())
    .Returns(new NotificationResult { Success = true });

// 每次都返回同樣的結果
```

### 方式 2：Multiple Returns（重試情況）
```csharp
mockSender.Send(Arg.Any<Order>())
    .Returns(
        new NotificationResult { Success = false },  // 第 1 次
        new NotificationResult { Success = true }    // 第 2 次
    );

// 或使用 AndThen
mockSender.Send(Arg.Any<Order>())
    .Returns(new NotificationResult { Success = false })
    .AndThen(new NotificationResult { Success = true });
```

---

## Received() 驗證用法

```csharp
// 驗證被呼叫 1 次
mockSender.Received(1).Send(order);

// 驗證被呼叫 3 次（重試情況）
mockSender.Received(3).Send(order);

// 驗證沒有被呼叫
mockSender.DidNotReceive().Send(Arg.Any<Order>());

// 驗證被呼叫至少 1 次
mockSender.Received().Send(order);
```

---

## 常見錯誤

### ? 錯誤 1：忘記 null check
```csharp
// 錯誤
public TimeoutDecorator(INotificationSender sender)
{
    _innerSender = sender;  // 如果 null 會在後面出錯
}

// 正確
public TimeoutDecorator(INotificationSender sender)
{
    _innerSender = sender ?? throw new ArgumentNullException(nameof(sender));
}
```

### ? 錯誤 2：忘記呼叫 _innerSender.Send()
```csharp
// 錯誤
public NotificationResult Send(Order order)
{
    Console.WriteLine("發送中...");
    // 忘記呼叫 _innerSender.Send(order) ?
    return new NotificationResult { Success = true };
}

// 正確
public NotificationResult Send(Order order)
{
    Console.WriteLine("發送中...");
    var result = _innerSender.Send(order);  // ?
    Console.WriteLine("發送完成!");
    return result;
}
```

### ? 錯誤 3：命名空間不匹配
```csharp
// 確保都在這個命名空間
namespace OrderNotificationSystem.Decorators
{
    public class LoggingNotificationSenderDecorator : INotificationSender
    {
        // ...
    }
}
```

---

## 驗證成功的標誌

```bash
$ dotnet test

Testing project... 
Tests passed: 10 ?
Tests failed: 0

Output example:
[LOG] 開始發送通知 - 發送器: EmailNotificationSender, 訂單: ORD001
[LOG] 發送成功 - 發送器: EmailNotificationSender, 訊息: Email 已寄出
[RETRY] 第 2 次嘗試成功
[TIMEOUT] 超時控制異常...

? All tests passed!
```

---

## 延伸學習

### 這個模式被用在哪裡？
- **Java NIO**：`BufferedInputStream(new FileInputStream())`
- **Spring Framework**：代理和 AOP
- **Node.js**：中間件（Middleware）
- **設計模式**：Wrapper 別稱

### 進階版本
- **ChainOfResponsibility**：?似但每個物件?定是否??
- **Proxy Pattern**：相似但用於延遲加載、訪問控制
- **Strategy Pattern**：不同演算法的互?

---

## 一句話總結

> **用小的、單一職責的類組合出複雜功能，而不是寫一個龐大、混亂的類。**

?? 完成第 6 關，你就真正理解了面向對象設計！
