# ?? 訂單通知系統練習專案 - 進度總結

## ?? 專案概覽

這是一個從零開始學習 **DI / Interface / NUnit / 設計模式** 的完整練習專案。

---

## ?? 課程進度

| 關卡 | 主題 | 狀態 | 學習概念 |
|------|------|------|---------|
| **第 1 關** | 基礎項目搭建 | ? 完成 | Interface、DI、基本單元測試 |
| **第 2 關** | 新增發送器 | ? 完成 | 接口實現、對稱擴展 |
| **第 3 關** | Fake 發送器 | ? 完成 | Mock、測試雙替 |
| **第 4 關** | 驗證器注入 | ? 完成 | 多個依賴注入、Received() |
| **第 5 關** | 組合模式 | ? 完成 | Composite Pattern、集合 |
| **第 6 關** | 裝飾器模式 | ?? 進行中 | Decorator Pattern、職責分離 |
| **第 7 關** | 非同步編程 | ? 待做 | Async/Await、並行處理 |
| **第 8 關** | 發佈-訂閱 | ? 待做 | Pub/Sub Pattern、事件驅動 |

---

## ?? 目前的檔案結構

```
OrderNotificationSystem/
├── INotificationSender.cs
├── IOrderValidator.cs
├── Order.cs
├── NotificationResult.cs
├── OrderService.cs
├── EmailNotificationSender.cs
├── LineNotificationSender.cs
├── DefaultOrderValidator.cs
├── FakeNotificationSender.cs
├── CompositeNotificationSender.cs
│
└── Decorators/                              # ?? 第 6 關新增
    ├── LoggingNotificationSenderDecorator.cs
    ├── RetryNotificationSenderDecorator.cs
    └── TimeoutNotificationSenderDecorator.cs

OrderNotificationSystemTests/
├── Unit/
│   ├── OrderServiceTests.cs
│   ├── CompositeNotificationSenderTests.cs
│   │
│   └── Decorators/                          # ?? 第 6 關新增
│       ├── LoggingDecoratorTests.cs
│       ├── RetryDecoratorTests.cs
│       └── TimeoutDecoratorTests.cs
│
└── Integration/
    └── OrderServiceIntegrationTests.cs

OrderNotificationSystem\.github/
├── 練習專案主題.md                 # 完整指南（已更新至第 6 關）
├── 第6關說明.md                   # 第 6 關詳細說明
└── 課程進度.md                    # 本檔案
```

---

## ?? 第 6 關：裝飾器模式

### ?? 目標
不修改原有代碼，動態為對象添加新功能

### ?? 需要實現
1. **LoggingNotificationSenderDecorator** - 記錄發送過程
2. **RetryNotificationSenderDecorator** - 失敗自動重試
3. **TimeoutNotificationSenderDecorator** - 設置執行超時

### ? 檢查清單
- [ ] 建立 `OrderNotificationSystem/Decorators/` 資料夾
- [ ] 建立 3 個裝飾器檔案（複製 MD 中的代碼）
- [ ] 建立 `OrderNotificationSystemTests/Unit/Decorators/` 資料夾
- [ ] 建立 3 個測試檔案
- [ ] 執行 `dotnet test` 確保所有測試通過
- [ ] （可選）完成挑戰任務

### ?? 快速開始

```bash
# 1. 建立資料夾
mkdir OrderNotificationSystem\Decorators
mkdir OrderNotificationSystemTests\Unit\Decorators

# 2. 複製檔案（從 MD 檔案中的代碼）
# - LoggingNotificationSenderDecorator.cs
# - RetryNotificationSenderDecorator.cs
# - TimeoutNotificationSenderDecorator.cs
# + 對應的 3 個測試檔案

# 3. 執行測試
dotnet test

# 4. 查看輸出
# ? All tests passed!
```

---

## ?? 已學習的設計模式

### 1. 依賴注入 (Dependency Injection)
```csharp
// 依賴從外部注入，而不是內部 new
public class OrderService
{
    public OrderService(IOrderValidator validator, INotificationSender sender) { }
}
```

### 2. 策略模式 (Strategy Pattern)
```csharp
// 多個實現可互換
INotificationSender sender = new EmailNotificationSender();
// 或
INotificationSender sender = new LineNotificationSender();
```

### 3. 組合模式 (Composite Pattern)
```csharp
// 同時使用多個發送器
var composite = new CompositeNotificationSender(
    new EmailNotificationSender(),
    new LineNotificationSender()
);
```

### 4. 裝飾器模式 (Decorator Pattern) ? 第 6 關
```csharp
// 動態添加功能
var sender = new EmailNotificationSender();
var withLog = new LoggingNotificationSenderDecorator(sender);
var withRetry = new RetryNotificationSenderDecorator(withLog);
```

---

## ?? 測試策略

### 單元測試
- **位置**：`Tests/Unit/`
- **使用 Mock**：? Substitute.For<>()
- **速度**：? 秒級
- **執行時機**：每次存檔

### 整合測試
- **位置**：`Tests/Integration/`
- **使用真實類**：? EmailNotificationSender、DefaultOrderValidator
- **速度**：?? 分鐘級
- **執行時機**：提交前

---

## ?? 核心理念

### 你能用 Fake 測試，代表架構是對的
```csharp
// ? 好的架構：可以用 Fake 替換
var sender = new FakeNotificationSender();
var service = new OrderService(validator, sender);

// ? 不好的架構：無法替換
// OrderService 內部寫死 new EmailNotificationSender()
```

### SOLID 原則的實踐

| 原則 | 第幾關 | 例子 |
|------|--------|------|
| **S** - 單一責任 | 6 | 每個裝飾器只做一件事 |
| **O** - 開放閉合 | 5、6 | 可擴展新發送器，無需修改舊代碼 |
| **L** - 里氏替換 | 2、3 | 所有實現都可替換 |
| **I** - 接口隔離 | 1、4 | 小而專的接口 |
| **D** - 依賴倒轉 | 1 | 依賴抽象而非具體 |

---

## ?? 獲得的技能

### C# 語言
? Interface、Namespace、Generics  
? LINQ、Lambda、Exception Handling  
? Task、async/await（將在第 7 關）  

### 測試技術
? NUnit Framework  
? NSubstitute（Mock 框架）  
? Arrange-Act-Assert 模式  
? Received()、DidNotReceive() 驗證  

### 設計模式
? Dependency Injection  
? Strategy、Composite、Decorator  
? （待學）Factory、Observer（Pub/Sub）  

### 工程實踐
? 單元測試 vs 整合測試  
? Mock vs Real Implementation  
? 測試金字塔  
? 持續整合（CI/CD 觀念）  

---

## ?? 下一步

### 立即行動
1. 完成第 6 關的所有步驟
2. 確保 `dotnet test` 全部通過 ?
3. 探索挑戰任務（指數退避、快取、熔斷器）

### 選擇路線

**路線 A：深入非同步**
- 第 7 關：非同步編程（Async/Await）
- 目標：並行發送多個通知，提高性能

**路線 B：深入事件驅動**
- 第 8 關：發佈-訂閱模式（Pub/Sub）
- 目標：解耦系統，實現觀察者模式

**建議：先 A 後 B** ??

---

## ?? 學習資源

### 本專案內
- `練習專案主題.md` - 完整指南（所有內容）
- `第6關說明.md` - 第 6 關詳細說明

### 推薦閱讀
- 《Clean Code》- Robert C. Martin
- 《設計模式》- Gang of Four
- 《重構：改善既有代碼的設計》- Martin Fowler

---

## ?? 常見問題

### Q: 為什麼要分別建立 Unit 和 Integration 測試？
**A:** 不同的目的：
- Unit：驗證單個類別的邏輯（快速反饋）
- Integration：驗證多個類別的協作（真實場景）

### Q: Mock 什麼時候用，什麼時候不用？
**A:**
- 用 Mock：單元測試（隔離依賴）
- 不用 Mock：整合測試（測試協作）

### Q: 裝飾器和繼承有什麼區別？
**A:**
```csharp
// 繼承：靜態，編譯時決定
public class EmailWithLog : EmailNotificationSender { }

// 裝飾器：動態，運行時組合
var sender = new LoggingDecorator(new EmailNotificationSender());
```

---

## ?? 需要幫助？

如果你在某個步驟卡住了，告訴我：
- 具體是哪一步
- 錯誤訊息
- 已嘗試的解決方案

我會立即幫助！ ??

---

## ? 最後的話

這個專案教的不只是代碼，而是 **如何寫出可測試、可維護、可擴展的軟體**。

這些技能在企業開發中非常寶貴。堅持下去，你會成為更好的開發者！

**加油！** ??
