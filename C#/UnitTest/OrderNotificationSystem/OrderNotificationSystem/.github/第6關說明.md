# ?? 第 6 關：裝飾器模式（Decorator Pattern）

## ?? 快速索引

| 項目 | 說明 |
|------|------|
| **主題** | 設計模式：裝飾器模式 |
| **難度** | ??? 進階 |
| **學習時間** | 2-3 小時 |
| **先修知識** | 第 1-5 關 |
| **預期成果** | 理解如何不修改原有代碼動態添加功能 |

---

## ?? 核心概念

### 什麼是裝飾器模式？

裝飾器模式（Decorator Pattern）是一種結構型設計模式，**允許你動態地為對象添加新功能，同時保持原有對象不變**。

### 為什麼需要它？

#### ? 不用裝飾器（代碼膨脹）
```csharp
// EmailNotificationSender 變得龐大且職責混亂
public class EmailNotificationSender : INotificationSender
{
    public NotificationResult Send(Order order)
    {
        // 原有邏輯
        // + 日誌代碼 (100 行)
        // + 重試代碼 (80 行)
        // + 超時代碼 (60 行)
        // + 快取代碼 (70 行)
        // = 總共 310+ 行代碼！
        // 修改任何一部分都風險很高
    }
}
```

#### ? 使用裝飾器（職責清晰）
```csharp
// 每個裝飾器只負責一件事
var sender = new EmailNotificationSender();                    // 原始功能
var withLog = new LoggingNotificationSenderDecorator(sender);  // +日誌
var withRetry = new RetryNotificationSenderDecorator(withLog); // +重試
var withTimeout = new TimeoutNotificationSenderDecorator(withRetry); // +超時
```

---

## ?? 需要完成的檔案

### 1. 核心實現 (3 個裝飾器)

#### OrderNotificationSystem/Decorators/LoggingNotificationSenderDecorator.cs
```csharp
namespace OrderNotificationSystem.Decorators
{
    public class LoggingNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;

        public LoggingNotificationSenderDecorator(INotificationSender innerSender)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
        }

        public NotificationResult Send(Order order)
        {
            var senderType = _innerSender.GetType().Name;
            Console.WriteLine($"[LOG] 開始發送通知 - 發送器: {senderType}, 訂單: {order.OrderNo}");

            try
            {
                var result = _innerSender.Send(order);
                var status = result.Success ? "成功" : "失敗";
                Console.WriteLine($"[LOG] 發送{status} - 發送器: {senderType}, 訊息: {result.Message}");
                return result;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[LOG] 發送異常 - 發送器: {senderType}, 異常: {ex.Message}");
                throw;
            }
        }
    }
}
```

#### OrderNotificationSystem/Decorators/RetryNotificationSenderDecorator.cs
```csharp
namespace OrderNotificationSystem.Decorators
{
    public class RetryNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _maxRetries;
        private readonly int _delayMs;

        public RetryNotificationSenderDecorator(
            INotificationSender innerSender,
            int maxRetries = 3,
            int delayMs = 100)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _maxRetries = maxRetries;
            _delayMs = delayMs;
        }

        public NotificationResult Send(Order order)
        {
            int attemptCount = 0;
            Exception lastException = null;

            while (attemptCount < _maxRetries)
            {
                try
                {
                    attemptCount++;
                    var result = _innerSender.Send(order);

                    if (result.Success)
                    {
                        if (attemptCount > 1)
                            Console.WriteLine($"[RETRY] 第 {attemptCount} 次嘗試成功");
                        return result;
                    }
                    else if (attemptCount < _maxRetries)
                    {
                        Console.WriteLine($"[RETRY] 第 {attemptCount} 次失敗，準備重試...");
                        System.Threading.Thread.Sleep(_delayMs);
                    }
                    else
                    {
                        return result;
                    }
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    if (attemptCount < _maxRetries)
                    {
                        Console.WriteLine($"[RETRY] 第 {attemptCount} 次異常，準備重試...");
                        System.Threading.Thread.Sleep(_delayMs);
                    }
                }
            }

            return new NotificationResult
            {
                Success = false,
                Message = $"經過 {_maxRetries} 次重試仍然失敗。最後異常: {lastException?.Message}"
            };
        }
    }
}
```

#### OrderNotificationSystem/Decorators/TimeoutNotificationSenderDecorator.cs
```csharp
using System.Threading.Tasks;

namespace OrderNotificationSystem.Decorators
{
    public class TimeoutNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _timeoutMs;

        public TimeoutNotificationSenderDecorator(
            INotificationSender innerSender,
            int timeoutMs = 5000)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _timeoutMs = timeoutMs;
        }

        public NotificationResult Send(Order order)
        {
            try
            {
                var task = Task.Run(() => _innerSender.Send(order));

                if (task.Wait(TimeSpan.FromMilliseconds(_timeoutMs)))
                {
                    return task.Result;
                }
                else
                {
                    Console.WriteLine($"[TIMEOUT] 發送超時 (>{_timeoutMs}ms)");
                    return new NotificationResult
                    {
                        Success = false,
                        Message = $"發送超時，超過 {_timeoutMs}ms"
                    };
                }
            }
            catch (AggregateException ex)
            {
                return new NotificationResult
                {
                    Success = false,
                    Message = $"超時控制異常: {ex.InnerException?.Message}"
                };
            }
        }
    }
}
```

### 2. 單元測試 (3 個測試檔案)

#### OrderNotificationSystemTests/Unit/Decorators/LoggingDecoratorTests.cs
- ? 測試成功情況
- ? 測試失敗情況  
- ? 測試異常情況

#### OrderNotificationSystemTests/Unit/Decorators/RetryDecoratorTests.cs
- ? 第一次成功
- ? 失敗後重試成功
- ? 全部重試都失敗
- ? 異常情況重試

#### OrderNotificationSystemTests/Unit/Decorators/TimeoutDecoratorTests.cs
- ? 在時限內完成
- ? 超時情況
- ? 異常處理

---

## ?? 實施步驟

### Step 1: 建立資料夾
```bash
mkdir OrderNotificationSystem\Decorators
mkdir OrderNotificationSystemTests\Unit\Decorators
```

### Step 2: 建立 3 個裝飾器檔案
複製上面的核心實現代碼到對應的檔案

### Step 3: 建立 3 個測試檔案
完整的測試代碼可以在 MD 檔案中找到

### Step 4: 執行測試
```bash
dotnet test
```

確保所有測試 ? 通過

---

## ?? 使用示例

### 基本用法
```csharp
var sender = new EmailNotificationSender();
var withLog = new LoggingNotificationSenderDecorator(sender);
var withRetry = new RetryNotificationSenderDecorator(withLog, maxRetries: 3);
var withTimeout = new TimeoutNotificationSenderDecorator(withRetry, timeoutMs: 5000);

var order = new Order { OrderNo = "ORD001", Amount = 1000 };
var result = withTimeout.Send(order);
```

### 執行流程
```
呼叫 withTimeout.Send()
  ↓
設置 5 秒超時
  ↓
進入 withRetry.Send()
  ↓
最多重試 3 次
  ↓
進入 withLog.Send()
  ↓
記錄開始/結束
  ↓
進入 EmailNotificationSender.Send()
  ↓
執行實際發送邏輯
```

### 在 OrderService 中使用
```csharp
var validator = new DefaultOrderValidator();

var emailSender = new LoggingNotificationSenderDecorator(
    new RetryNotificationSenderDecorator(
        new EmailNotificationSender(),
        maxRetries: 3
    )
);

var orderService = new OrderService(validator, emailSender);
```

---

## ?? 關鍵概念

### ? 開放-閉合原則（Open/Closed Principle）
- **開放於擴展**：可以添加新的裝飾器（LoggingDecorator、RetryDecorator...）
- **閉合於修改**：不需要修改原有的 EmailNotificationSender

### ? 職責單一（Single Responsibility）
- LoggingDecorator：只負責日誌
- RetryDecorator：只負責重試
- TimeoutDecorator：只負責超時
- 每個類只做一件事，做好它

### ? 組合優於繼承
```csharp
// ? 如果用繼承：需要創建這些類
EmailNotificationSender
EmailNotificationSenderWithLog
EmailNotificationSenderWithLogAndRetry
EmailNotificationSenderWithLogAndRetryAndTimeout
// 類爆炸！

// ? 如果用裝飾器：靈活組合
new TimeoutNotificationSenderDecorator(
    new RetryNotificationSenderDecorator(
        new LoggingNotificationSenderDecorator(
            new EmailNotificationSender()
        )
    )
)
```

---

## ? 預期成果

完成第 6 關後，你應該能夠：

? 理解裝飾器模式的核心思想  
? 實現可堆疊的功能組合  
? 使用 NSubstitute 測試裝飾器  
? 認識「組合優於繼承」的優勢  
? 遵循 SOLID 原則設計代碼  

---

## ?? 挑戰任務

### 難度 ??：指數退避重試
修改 RetryDecorator 讓重試延遲自動遞增：
- 第 1 次重試：100ms
- 第 2 次重試：200ms
- 第 3 次重試：400ms

### 難度 ???：快取裝飾器
建立 `CacheNotificationSenderDecorator`：
- 如果 5 秒內收到相同訂單號，使用快取結果
- 5 秒後快取過期，重新發送
- 寫出完整的單元測試

### 難度 ????：熔斷器
建立 `CircuitBreakerDecorator`：
- 連續失敗 5 次後自動停止（開路）
- 30 秒後自動嘗試恢復（半開）
- 成功後完全恢復（閉合）
- 類似於電路斷路器的行為

---

## ?? 遇到問題？

1. **測試失敗？** 檢查：
   - 檔案是否在正確的命名空間
   - 是否引入了必要的 `using` 陳述式
   - Mock 的設置是否正確

2. **類找不到？** 檢查：
   - 資料夾結構是否正確
   - 是否編譯成功

3. **邏輯不清楚？** 建議：
   - 重新閱讀裝飾器模式的說明
   - 查看使用示例
   - 在調試器中逐步執行代碼

---

## ? 完成後的下一步

當你完成第 6 關並所有測試都通過時，可以選擇：

?? **第 7 關：非同步編程（Async/Await）**
- 使 NotificationSender 支持非同步操作
- 並行發送多個通知
- 處理非同步超時

?? **第 8 關：發佈-訂閱模式（Pub/Sub）**
- 解耦發送器和接收器
- 支持多個訂閱者
- 實現事件驅動架構

---

**祝你完成第 6 關！** ??
