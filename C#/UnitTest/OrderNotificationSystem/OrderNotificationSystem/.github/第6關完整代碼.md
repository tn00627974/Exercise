# 第 6 關完整代碼參考

## 核心實現代碼（可直接複製）

### 1. LoggingNotificationSenderDecorator.cs

?? 位置：`OrderNotificationSystem/Decorators/LoggingNotificationSenderDecorator.cs`

```csharp
using System;

namespace OrderNotificationSystem.Decorators
{
    /// <summary>
    /// 日誌裝飾器：記錄每次發送的情況
    /// </summary>
    public class LoggingNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;

        public LoggingNotificationSenderDecorator(INotificationSender innerSender)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
        }

        public NotificationResult Send(Order order)
        {
            var senderType = _innerSender.GetType().Name;
            
            // 記錄開始
            Console.WriteLine($"[LOG] 開始發送通知 - 發送器: {senderType}, 訂單: {order.OrderNo}");

            try
            {
                var result = _innerSender.Send(order);
                
                // 記錄結果
                var status = result.Success ? "成功" : "失敗";
                Console.WriteLine($"[LOG] 發送{status} - 發送器: {senderType}, 訊息: {result.Message}");

                return result;
            }
            catch (Exception ex)
            {
                // 記錄異常
                Console.WriteLine($"[LOG] 發送異常 - 發送器: {senderType}, 異常: {ex.Message}");
                throw;
            }
        }
    }
}
```

---

### 2. RetryNotificationSenderDecorator.cs

?? 位置：`OrderNotificationSystem/Decorators/RetryNotificationSenderDecorator.cs`

```csharp
using System;

namespace OrderNotificationSystem.Decorators
{
    /// <summary>
    /// 重試裝飾器：失敗時自動重試
    /// </summary>
    public class RetryNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _maxRetries;
        private readonly int _delayMs;

        public RetryNotificationSenderDecorator(
            INotificationSender innerSender, 
            int maxRetries = 3, 
            int delayMs = 100)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _maxRetries = maxRetries;
            _delayMs = delayMs;
        }

        public NotificationResult Send(Order order)
        {
            int attemptCount = 0;
            Exception lastException = null;

            while (attemptCount < _maxRetries)
            {
                try
                {
                    attemptCount++;
                    var result = _innerSender.Send(order);

                    if (result.Success)
                    {
                        if (attemptCount > 1)
                        {
                            Console.WriteLine($"[RETRY] 第 {attemptCount} 次嘗試成功");
                        }
                        return result;
                    }
                    else
                    {
                        // 失敗，如果還有重試次數則繼續
                        if (attemptCount < _maxRetries)
                        {
                            Console.WriteLine($"[RETRY] 第 {attemptCount} 次失敗，準備重試... 訊息: {result.Message}");
                            System.Threading.Thread.Sleep(_delayMs);
                        }
                        else
                        {
                            return result;
                        }
                    }
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    
                    if (attemptCount < _maxRetries)
                    {
                        Console.WriteLine($"[RETRY] 第 {attemptCount} 次異常，準備重試... 異常: {ex.Message}");
                        System.Threading.Thread.Sleep(_delayMs);
                    }
                }
            }

            // 如果走到這裡表示全部重試都失敗了
            return new NotificationResult
            {
                Success = false,
                Message = $"經過 {_maxRetries} 次重試仍然失敗。最後異常: {lastException?.Message}"
            };
        }
    }
}
```

---

### 3. TimeoutNotificationSenderDecorator.cs

?? 位置：`OrderNotificationSystem/Decorators/TimeoutNotificationSenderDecorator.cs`

```csharp
using System;
using System.Threading;
using System.Threading.Tasks;

namespace OrderNotificationSystem.Decorators
{
    /// <summary>
    /// 超時裝飾器：避免發送器執行過長時間
    /// </summary>
    public class TimeoutNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _timeoutMs;

        public TimeoutNotificationSenderDecorator(INotificationSender innerSender, int timeoutMs = 5000)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _timeoutMs = timeoutMs;
        }

        public NotificationResult Send(Order order)
        {
            try
            {
                // 使用 Task 和 Wait 實現超時控制
                var task = Task.Run(() => _innerSender.Send(order));
                
                if (task.Wait(TimeSpan.FromMilliseconds(_timeoutMs)))
                {
                    return task.Result;
                }
                else
                {
                    Console.WriteLine($"[TIMEOUT] 發送超時 (>{_timeoutMs}ms)，訂單: {order.OrderNo}");
                    return new NotificationResult
                    {
                        Success = false,
                        Message = $"發送超時，超過 {_timeoutMs}ms"
                    };
                }
            }
            catch (AggregateException ex)
            {
                return new NotificationResult
                {
                    Success = false,
                    Message = $"超時控制異常: {ex.InnerException?.Message}"
                };
            }
        }
    }
}
```

---

## 測試代碼（可直接複製）

### 1. LoggingDecoratorTests.cs

?? 位置：`OrderNotificationSystemTests/Unit/Decorators/LoggingDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class LoggingDecoratorTests
    {
        private INotificationSender _mockSender;
        private LoggingNotificationSenderDecorator _decorator;

        [SetUp]
        public void Setup()
        {
            _mockSender = Substitute.For<INotificationSender>();
            _decorator = new LoggingNotificationSenderDecorator(_mockSender);
        }

        [Test]
        public void Send_WhenInnerSenderSucceeds_PassesThroughResult()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult 
            { 
                Success = true, 
                Message = "Sent successfully" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.True);
            Assert.That(result.Message, Is.EqualTo("Sent successfully"));
            _mockSender.Received(1).Send(order);
        }

        [Test]
        public void Send_WhenInnerSenderFails_PassesFailureThrough()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD002", Amount = 100 };
            var expectedResult = new NotificationResult 
            { 
                Success = false, 
                Message = "Send failed" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.False);
            Assert.That(result.Message, Is.EqualTo("Send failed"));
        }

        [Test]
        public void Send_WhenInnerSenderThrows_ThrowsException()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD003", Amount = 500 };
            _mockSender.Send(order).Throws(new InvalidOperationException("Network error"));

            // Act & Assert
            Assert.Throws<InvalidOperationException>(() => _decorator.Send(order));
        }
    }
}
```

---

### 2. RetryDecoratorTests.cs

?? 位置：`OrderNotificationSystemTests/Unit/Decorators/RetryDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class RetryDecoratorTests
    {
        private INotificationSender _mockSender;
        private RetryNotificationSenderDecorator _decorator;

        [SetUp]
        public void Setup()
        {
            _mockSender = Substitute.For<INotificationSender>();
            _decorator = new RetryNotificationSenderDecorator(_mockSender, maxRetries: 3, delayMs: 10);
        }

        [Test]
        public void Send_FirstAttemptSucceeds_ReturnSuccess()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult 
            { 
                Success = true, 
                Message = "Success on first try" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.True);
            _mockSender.Received(1).Send(order);
        }

        [Test]
        public void Send_FailsThenSucceeds_RetryUntilSuccess()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD002", Amount = 500 };
            var failResult = new NotificationResult { Success = false, Message = "Temporary failure" };
            var successResult = new NotificationResult { Success = true, Message = "Success after retry" };
            
            _mockSender.Send(order)
                .Returns(failResult)      // 第 1 次失敗
                .AndThen(successResult);  // 第 2 次成功

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.True);
            _mockSender.Received(2).Send(order);
        }

        [Test]
        public void Send_FailsAllAttempts_ReturnFailure()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD003", Amount = 100 };
            var failResult = new NotificationResult { Success = false, Message = "Always fails" };
            
            _mockSender.Send(order).Returns(failResult);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.False);
            Assert.That(result.Message, Contains.Substring("3 次重試"));
            _mockSender.Received(3).Send(order);
        }

        [Test]
        public void Send_ThrowsExceptionThenSucceeds_RetryOnException()
        {
            // Arrange
            var order = new Order { OrderNo = "ORD004", Amount = 200 };
            var successResult = new NotificationResult { Success = true, Message = "Success after exception" };
            
            _mockSender.Send(order)
                .Throws(new System.Net.HttpRequestException("Network timeout"))
                .AndThen(successResult);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.True);
            _mockSender.Received(2).Send(order);
        }
    }
}
```

---

### 3. TimeoutDecoratorTests.cs

?? 位置：`OrderNotificationSystemTests/Unit/Decorators/TimeoutDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class TimeoutDecoratorTests
    {
        private TimeoutNotificationSenderDecorator _decorator;

        [Test]
        public void Send_WhenCompletsWithinTimeout_ReturnsSuccess()
        {
            // Arrange
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult { Success = true, Message = "Fast response" };
            
            mockSender.Send(order).Returns(expectedResult);
            _decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 5000);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.True);
        }

        [Test]
        public void Send_WhenExceedsTimeout_ReturnTimeout()
        {
            // Arrange
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD002", Amount = 500 };
            
            mockSender.Send(order).Returns(_ =>
            {
                Thread.Sleep(2000);
                return new NotificationResult { Success = true, Message = "Too slow" };
            });
            
            _decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 500);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.False);
            Assert.That(result.Message, Contains.Substring("超時"));
        }

        [Test]
        public void Send_WhenThrowsException_CatchesAndReturnsFailure()
        {
            // Arrange
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD003", Amount = 100 };
            
            mockSender.Send(order).Throws(new InvalidOperationException("Critical error"));
            _decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 5000);

            // Act
            var result = _decorator.Send(order);

            // Assert
            Assert.That(result.Success, Is.False);
            Assert.That(result.Message, Contains.Substring("異常"));
        }
    }
}
```

---

## 使用示例

### 例子 1：基本用法
```csharp
var sender = new EmailNotificationSender();
var withLog = new LoggingNotificationSenderDecorator(sender);
var order = new Order { OrderNo = "ORD001", Amount = 1000 };
var result = withLog.Send(order);

// 控制台輸出：
// [LOG] 開始發送通知 - 發送器: EmailNotificationSender, 訂單: ORD001
// [LOG] 發送成功 - 發送器: EmailNotificationSender, 訊息: Email 已寄出，訂單：ORD001
```

### 例子 2：組合多個裝飾器
```csharp
var sender = new EmailNotificationSender();
var withLog = new LoggingNotificationSenderDecorator(sender);
var withRetry = new RetryNotificationSenderDecorator(withLog, maxRetries: 3, delayMs: 100);
var withTimeout = new TimeoutNotificationSenderDecorator(withRetry, timeoutMs: 5000);

var order = new Order { OrderNo = "ORD002", Amount = 500 };
var result = withTimeout.Send(order);
```

### 例子 3：在 OrderService 中使用
```csharp
var validator = new DefaultOrderValidator();

// 建立裝飾的發送器
var emailSender = new LoggingNotificationSenderDecorator(
    new RetryNotificationSenderDecorator(
        new TimeoutNotificationSenderDecorator(
            new EmailNotificationSender()
        )
    )
);

var orderService = new OrderService(validator, emailSender);

var order = new Order { OrderNo = "ORD003", Amount = 1500 };
var result = orderService.PlaceOrder(order);
```

---

## 快速檢查清單

```bash
? 建立資料夾
  └─ OrderNotificationSystem/Decorators/
  └─ OrderNotificationSystemTests/Unit/Decorators/

? 複製 3 個核心檔案
  ├─ LoggingNotificationSenderDecorator.cs
  ├─ RetryNotificationSenderDecorator.cs
  └─ TimeoutNotificationSenderDecorator.cs

? 複製 3 個測試檔案
  ├─ LoggingDecoratorTests.cs
  ├─ RetryDecoratorTests.cs
  └─ TimeoutDecoratorTests.cs

? 執行測試
  $ dotnet test
  # ? All tests passed!

? 驗證使用
  var sender = new EmailNotificationSender();
  var decorated = new LoggingNotificationSenderDecorator(sender);
  decorated.Send(order); // ? 工作正常
```

---

**祝你完成第 6 關！** ??
