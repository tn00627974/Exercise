# 第 6 關完整代碼參考

## 核心實現代碼

### LoggingNotificationSenderDecorator.cs ??

位置：`OrderNotificationSystem/Decorators/LoggingNotificationSenderDecorator.cs`

```csharp
using System;

namespace OrderNotificationSystem.Decorators
{
    public class LoggingNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;

        public LoggingNotificationSenderDecorator(INotificationSender innerSender)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
        }

        public NotificationResult Send(Order order)
        {
            var senderType = _innerSender.GetType().Name;
            
            Console.WriteLine($"[LOG] 開始發送通知 - 發送器: {senderType}, 訂單: {order.OrderNo}");

            try
            {
                var result = _innerSender.Send(order);
                
                var status = result.Success ? "成功" : "失敗";
                Console.WriteLine($"[LOG] 發送{status} - 發送器: {senderType}, 訊息: {result.Message}");

                return result;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[LOG] 發送異常 - 發送器: {senderType}, 異常: {ex.Message}");
                throw;
            }
        }
    }
}
```

---

### RetryNotificationSenderDecorator.cs

位置：`OrderNotificationSystem/Decorators/RetryNotificationSenderDecorator.cs`

```csharp
using System;

namespace OrderNotificationSystem.Decorators
{
    public class RetryNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _maxRetries;
        private readonly int _delayMs;

        public RetryNotificationSenderDecorator(
            INotificationSender innerSender, 
            int maxRetries = 3, 
            int delayMs = 100)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _maxRetries = maxRetries;
            _delayMs = delayMs;
        }

        public NotificationResult Send(Order order)
        {
            int attemptCount = 0;
            Exception lastException = null;

            while (attemptCount < _maxRetries)
            {
                try
                {
                    attemptCount++;
                    var result = _innerSender.Send(order);

                    if (result.Success)
                    {
                        if (attemptCount > 1)
                            Console.WriteLine($"[RETRY] 第 {attemptCount} 次嘗試成功");
                        return result;
                    }
                    else if (attemptCount < _maxRetries)
                    {
                        Console.WriteLine($"[RETRY] 第 {attemptCount} 次失敗，準備重試...");
                        System.Threading.Thread.Sleep(_delayMs);
                    }
                    else
                    {
                        return result;
                    }
                }
                catch (Exception ex)
                {
                    lastException = ex;
                    if (attemptCount < _maxRetries)
                    {
                        Console.WriteLine($"[RETRY] 第 {attemptCount} 次異常，準備重試...");
                        System.Threading.Thread.Sleep(_delayMs);
                    }
                }
            }

            return new NotificationResult
            {
                Success = false,
                Message = $"經過 {_maxRetries} 次重試仍然失敗"
            };
        }
    }
}
```

---

### TimeoutNotificationSenderDecorator.cs

位置：`OrderNotificationSystem/Decorators/TimeoutNotificationSenderDecorator.cs`

```csharp
using System;
using System.Threading.Tasks;

namespace OrderNotificationSystem.Decorators
{
    public class TimeoutNotificationSenderDecorator : INotificationSender
    {
        private readonly INotificationSender _innerSender;
        private readonly int _timeoutMs;

        public TimeoutNotificationSenderDecorator(
            INotificationSender innerSender, 
            int timeoutMs = 5000)
        {
            _innerSender = innerSender ?? throw new ArgumentNullException(nameof(innerSender));
            _timeoutMs = timeoutMs;
        }

        public NotificationResult Send(Order order)
        {
            try
            {
                var task = Task.Run(() => _innerSender.Send(order));
                
                if (task.Wait(TimeSpan.FromMilliseconds(_timeoutMs)))
                {
                    return task.Result;
                }
                else
                {
                    Console.WriteLine($"[TIMEOUT] 發送超時 (>{_timeoutMs}ms)");
                    return new NotificationResult
                    {
                        Success = false,
                        Message = $"發送超時，超過 {_timeoutMs}ms"
                    };
                }
            }
            catch (AggregateException ex)
            {
                return new NotificationResult
                {
                    Success = false,
                    Message = $"超時控制異常: {ex.InnerException?.Message}"
                };
            }
        }
    }
}
```

---

## 測試代碼

### LoggingDecoratorTests.cs

位置：`OrderNotificationSystemTests/Unit/Decorators/LoggingDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class LoggingDecoratorTests
    {
        private INotificationSender _mockSender;
        private LoggingNotificationSenderDecorator _decorator;

        [SetUp]
        public void Setup()
        {
            _mockSender = Substitute.For<INotificationSender>();
            _decorator = new LoggingNotificationSenderDecorator(_mockSender);
        }

        [Test]
        public void Send_WhenSucceeds_PassesThroughResult()
        {
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult 
            { 
                Success = true, 
                Message = "Sent successfully" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);
            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.True);
            _mockSender.Received(1).Send(order);
        }

        [Test]
        public void Send_WhenFails_PassesFailureThrough()
        {
            var order = new Order { OrderNo = "ORD002", Amount = 100 };
            var expectedResult = new NotificationResult 
            { 
                Success = false, 
                Message = "Send failed" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);
            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.False);
        }

        [Test]
        public void Send_WhenThrowsException_ThrowsException()
        {
            var order = new Order { OrderNo = "ORD003", Amount = 500 };
            _mockSender.Send(order).Throws(new InvalidOperationException("Network error"));

            Assert.Throws<InvalidOperationException>(() => _decorator.Send(order));
        }
    }
}
```

---

### RetryDecoratorTests.cs

位置：`OrderNotificationSystemTests/Unit/Decorators/RetryDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class RetryDecoratorTests
    {
        private INotificationSender _mockSender;
        private RetryNotificationSenderDecorator _decorator;

        [SetUp]
        public void Setup()
        {
            _mockSender = Substitute.For<INotificationSender>();
            _decorator = new RetryNotificationSenderDecorator(_mockSender, maxRetries: 3, delayMs: 10);
        }

        [Test]
        public void Send_FirstAttemptSucceeds_ReturnSuccess()
        {
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult 
            { 
                Success = true, 
                Message = "Success on first try" 
            };
            
            _mockSender.Send(order).Returns(expectedResult);
            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.True);
            _mockSender.Received(1).Send(order);
        }

        [Test]
        public void Send_FailsThenSucceeds_RetryUntilSuccess()
        {
            var order = new Order { OrderNo = "ORD002", Amount = 500 };
            var failResult = new NotificationResult { Success = false };
            var successResult = new NotificationResult { Success = true };
            
            _mockSender.Send(order)
                .Returns(failResult)
                .AndThen(successResult);

            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.True);
            _mockSender.Received(2).Send(order);
        }

        [Test]
        public void Send_FailsAllAttempts_ReturnFailure()
        {
            var order = new Order { OrderNo = "ORD003", Amount = 100 };
            var failResult = new NotificationResult { Success = false };
            
            _mockSender.Send(order).Returns(failResult);
            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.False);
            _mockSender.Received(3).Send(order);
        }

        [Test]
        public void Send_ThrowsExceptionThenSucceeds_RetryOnException()
        {
            var order = new Order { OrderNo = "ORD004", Amount = 200 };
            var successResult = new NotificationResult { Success = true };
            
            _mockSender.Send(order)
                .Throws(new System.Net.HttpRequestException("Network timeout"))
                .AndThen(successResult);

            var result = _decorator.Send(order);

            Assert.That(result.Success, Is.True);
            _mockSender.Received(2).Send(order);
        }
    }
}
```

---

### TimeoutDecoratorTests.cs

位置：`OrderNotificationSystemTests/Unit/Decorators/TimeoutDecoratorTests.cs`

```csharp
using NSubstitute;
using NUnit.Framework;
using OrderNotificationSystem;
using OrderNotificationSystem.Decorators;
using OrderNotificationSystem.Models;
using System;
using System.Threading;

namespace OrderNotificationSystemTests.Unit.Decorators
{
    public class TimeoutDecoratorTests
    {
        [Test]
        public void Send_WhenCompletsWithinTimeout_ReturnsSuccess()
        {
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD001", Amount = 1000 };
            var expectedResult = new NotificationResult { Success = true };
            
            mockSender.Send(order).Returns(expectedResult);
            var decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 5000);

            var result = decorator.Send(order);

            Assert.That(result.Success, Is.True);
        }

        [Test]
        public void Send_WhenExceedsTimeout_ReturnTimeout()
        {
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD002", Amount = 500 };
            
            mockSender.Send(order).Returns(_ =>
            {
                Thread.Sleep(2000);
                return new NotificationResult { Success = true };
            });
            
            var decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 500);
            var result = decorator.Send(order);

            Assert.That(result.Success, Is.False);
        }

        [Test]
        public void Send_WhenThrowsException_CatchesAndReturnsFailure()
        {
            var mockSender = Substitute.For<INotificationSender>();
            var order = new Order { OrderNo = "ORD003", Amount = 100 };
            
            mockSender.Send(order).Throws(new InvalidOperationException("Critical error"));
            var decorator = new TimeoutNotificationSenderDecorator(mockSender, timeoutMs: 5000);

            var result = decorator.Send(order);

            Assert.That(result.Success, Is.False);
        }
    }
}
```

---

## 快速檢查

執行測試：
```bash
dotnet test
```

預期結果：
```
Total: 10 tests
Passed: 10 tests
Failed: 0 tests
```

完成後！??
